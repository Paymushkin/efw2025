{"file":"useVideoVisibility-CFiWwuHF.js","mappings":";AAMO,SAAS,mBAAmB,UAAyC;AAC1E,MAAI,WAAwC;AAC5C,QAAM,YAAY,IAAI,KAAK;AAC3B,QAAM,gCAAgB,IAAA;AAEtB,QAAM,qBAAqB,CAAC,YAAyC;AACnE,YAAQ,QAAQ,CAAA,UAAS;AACvB,YAAM,QAAQ,MAAM;AACpB,UAAI,CAAC,MAAO;AAEZ,gBAAU,QAAQ,MAAM;AAExB,UAAI,MAAM,gBAAgB;AAExB,cAAM,OAAO,MAAM,MAAM;AACvB,kBAAQ,IAAI,8CAA8C;AAAA,QAC5D,CAAC;AAAA,MACH,OAAO;AAEL,cAAM,MAAA;AAAA,MACR;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,cAAc,CAAC,IAA6B,QAAyB;AACzE,QAAI,IAAI;AACN,gBAAU,IAAI,KAAK,EAAE;AACrB,UAAI,CAAC,UAAU;AACb,mBAAW,IAAI,qBAAqB,oBAAoB;AAAA,UACtD,WAAW;AAAA,UACX,YAAY;AAAA,QAAA,CACb;AAAA,MACH;AACA,eAAS,QAAQ,EAAE;AAAA,IACrB,OAAO;AACL,YAAM,gBAAgB,UAAU,IAAI,GAAG;AACvC,UAAI,iBAAiB,UAAU;AAC7B,iBAAS,UAAU,aAAa;AAAA,MAClC;AACA,gBAAU,OAAO,GAAG;AAAA,IACtB;AAAA,EACF;AAEA,QAAM,UAAU,MAAM;AACpB,QAAI,UAAU;AACZ,eAAS,WAAA;AACT,iBAAW;AAAA,IACb;AACA,cAAU,MAAA;AAAA,EACZ;AAwBA,MAAI,UAAU;AAEZ,WAAO;AAAA,MACL;AAAA,IAAA;AAAA,EAEJ,OAAO;AAEL,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAEF;AACJ;","names":[],"sources":["../../../../composables/useVideoVisibility.ts"],"sourcesContent":["import { onMounted, onUnmounted, ref } from 'vue';\nimport type { Ref } from 'vue';\n\n// Overloaded function signatures\nexport function useVideoVisibility(videoRef: Ref<HTMLVideoElement | null>): { isVisible: Ref<boolean> };\nexport function useVideoVisibility(): { setVideoRef: (el: HTMLVideoElement | null, key: string | number) => void; cleanup: () => void; isVisible: Ref<boolean> };\nexport function useVideoVisibility(videoRef?: Ref<HTMLVideoElement | null>) {\n  let observer: IntersectionObserver | null = null;\n  const isVisible = ref(false);\n  const videoRefs = new Map<string | number, HTMLVideoElement>();\n\n  const handleIntersection = (entries: IntersectionObserverEntry[]) => {\n    entries.forEach(entry => {\n      const video = entry.target as HTMLVideoElement;\n      if (!video) return;\n\n      isVisible.value = entry.isIntersecting;\n\n      if (entry.isIntersecting) {\n        // Try to play when video becomes visible\n        video.play().catch(() => {\n          console.log('Playback failed, might need user interaction');\n        });\n      } else {\n        // Pause when video is not visible\n        video.pause();\n      }\n    });\n  };\n\n  const setVideoRef = (el: HTMLVideoElement | null, key: string | number) => {\n    if (el) {\n      videoRefs.set(key, el);\n      if (!observer) {\n        observer = new IntersectionObserver(handleIntersection, {\n          threshold: 0.5,\n          rootMargin: '50px'\n        });\n      }\n      observer.observe(el);\n    } else {\n      const existingVideo = videoRefs.get(key);\n      if (existingVideo && observer) {\n        observer.unobserve(existingVideo);\n      }\n      videoRefs.delete(key);\n    }\n  };\n\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = null;\n    }\n    videoRefs.clear();\n  };\n\n  onMounted(() => {\n    if (videoRef?.value) {\n      // Single video ref mode\n      if (!observer) {\n    observer = new IntersectionObserver(handleIntersection, {\n          threshold: 0.5,\n          rootMargin: '50px'\n    });\n      }\n    observer.observe(videoRef.value);\n\n    // Initial play attempt\n    videoRef.value.play().catch(() => {\n      console.log('Initial playback failed, might need user interaction');\n    });\n    }\n  });\n\n  onUnmounted(() => {\n    cleanup();\n  });\n\n  if (videoRef) {\n    // Single video ref mode\n    return {\n      isVisible\n    };\n  } else {\n    // Multiple video refs mode\n    return {\n      setVideoRef,\n      cleanup,\n      isVisible\n    };\n    }\n} "],"version":3}